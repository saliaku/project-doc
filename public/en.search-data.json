{"/about/":{"data":{"about-the-project#About the project":"","for-parents#For Parents":"About the projectPurpose This assessment aims to collect data on learners’ readability levels, information processing abilities, and working memory capacity. The information gathered will be used solely to train a model supporting an adaptive E-learning framework, which will leverage Genetic Algorithms (GA) to tailor educational resources to meet each learner’s unique needs, enhancing engagement and learning effectiveness. Your responses are confidential, will not be shared, and will not be used for any other purposes.\nFramework Overview In a world where traditional education systems struggle to cater to the diverse needs of neurodiverse students, our project seeks to create an innovative e-learning framework that prioritizes inclusivity, adaptability, and personalization. By harnessing the power of Machine Learning (ML), this framework aims to provide a dynamic, tailored educational experience for students with varying cognitive abilities and learning styles.\nThe framework is proposed to be built around three core components: user profiling, instructional content delivery, and personalized learning paths.\nUser Profiling: Involves creating detailed personal profiles for students, assessing their cognitive abilities, learning preferences, and individual strengths. This profile acts as the foundation for designing tailored learning experiences.\nInstructional Content Delivery: Content is presented in multimodal formats, including text, video, interactive media, and gamified elements, to address the varied sensory and cognitive needs of students.\nPersonalized Learning Paths: Learning paths are dynamically generated using Genetic Algorithms (GA), ensuring optimal sequencing of lessons while adhering to dependency relationships between topics using a technique called Layered Topological Sort (LTS).\nThrough this project, we hope to go beyond traditional education by empowering neurodiverse learners, providing them with the tools they need to succeed in a supportive and inclusive environment. By leveraging ML technologies, the framework ensures that every student receives a customized and engaging learning experience, regardless of geographical limitations or individual challenges.\nOur Motivation Our motivation stems from the growing need to create an inclusive educational environment where every student, regardless of their cognitive or learning abilities, can thrive. Traditional education systems often overlook the diverse needs of neurodiverse students, leaving them to navigate an inflexible and overwhelming framework that may not cater to their unique strengths and challenges.\nFor instance, students with conditions like ADHD, dyslexia, or autism spectrum disorder often face difficulties in focus, comprehension, and sensory processing. These challenges are exacerbated in environments that fail to offer tailored support, leading to feelings of frustration and disengagement. Our project seeks to address these gaps by providing a solution that not only meets the needs of neurodiverse students but also sets a new standard for adaptive learning.\nBeyond addressing individual challenges, this project is motivated by the potential to provide equal opportunities for students in remote and underserved areas. E-learning frameworks eliminate geographical barriers, ensuring that high-quality, customized education is accessible to all. This inclusivity is not just an option but a necessity in today’s interconnected world.\nHow This Can Be Beneficial Our e-learning framework directly addresses the challenges faced by neurodiverse students, offering a wide array of benefits that redefine the educational experience for these learners. Traditional systems often overlook the unique needs of individuals with ADHD, dyslexia, or other neurodiverse traits, leading to disengagement and frustration. Our framework seeks to change that narrative.\nKey Benefits: Personalized Learning Paths: By leveraging advanced Genetic Algorithms (GA), students are provided with optimal and customized learning paths that align with their individual profiles. This ensures that the learning process is not only effective but also enjoyable and engaging.\nMultimodal Content Delivery: Students receive instructional materials in formats best suited to their learning styles, whether it be visual, auditory, or interactive content. This variety ensures higher engagement and better retention of concepts.\nAccessibility for Remote Areas: The framework eliminates geographical barriers, providing high-quality education to students in remote areas without the need for physical presence or extensive resources like personal tutors.\nReal-Time Feedback and Adaptive Learning: Through ML, the system monitors student progress and provides real-time feedback, adapting learning paths based on their performance and engagement levels. This ensures continuous improvement and a more interactive experience.\nBy focusing on inclusivity, adaptability, and accessibility, our project transforms the way education is delivered to neurodiverse students, empowering them to overcome traditional learning challenges and unlock their full potential. The project currently focusses on personalization, with extension to including neurodiverse students a future scope.\nFor Parents As parents, you play a pivotal role in shaping your child’s educational journey. Our framework is designed to empower you with actionable insights and tools to support your child’s unique learning needs. Recognizing the challenges faced by neurodiverse learners, we aim to bridge the gap between educational expectations and individual capabilities, fostering an environment of growth and achievement. This project is a small step is personalizing the learning experience for the students, bringing it one step closer to including neurodiverse students.\nThe platform provides a detailed overview of your child’s learning preferences, progress, and areas of improvement through personalized reports and dashboards. These insights are generated using advanced Machine Learning (ML) algorithms that analyze patterns in learning behavior, cognitive abilities, and performance metrics. By understanding how your child learns best, you can better support their academic and personal growth.\nOur framework emphasizes flexibility and adaptability, offering recommendations tailored to your child’s strengths and challenges. Whether it’s suggesting multimodal content like videos, interactive activities, or gamified lessons, the system ensures that your child remains engaged and motivated throughout their learning journey.\nUltimately, our framework is not just about enhancing learning outcomes; it’s about creating a collaborative ecosystem where parents and educators work together to unlock each child’s potential. With this platform, you have a partner in your child’s education, ensuring that they receive the support they need to thrive in an inclusive, personalized, and empowering learning environment.","framework-overview#Framework Overview":"","how-this-can-be-beneficial#How This Can Be Beneficial":"","our-motivation#Our Motivation":"","purpose#Purpose":""},"title":"_index"},"/docs/":{"data":{"implementation#Implementation":"ImplementationTo support the implementation, the following sections offer a step-by-step guide for setting up the Moodle system according to the prototype’s specifications. From outlining the necessary system requirements to detailing the installation process and codebase integration, this documentation provides all the information needed to replicate the setup. Begin with the Getting Started section to review the prerequisites, then proceed to the Installation Guide for full configuration instructions."},"title":"_index"},"/docs/course-setup/":{"data":{"":"Add the steps for setting up course here."},"title":"Setting up the course"},"/docs/databases/":{"data":{"":"","fyp#fyp":"This section details the database tables used in the project. There are two databases:\nmoodle: Default database created by moodle to store moodle data fyp: Database created to store required information of the implementation moodle ℹ️ Note: moodle tables have many built-in fields. The schema of only the required section of tables is provided. Table: mdl_user Field Data Type Description id INT (AUTO INCREMENT) Auto increment identifier flesch INT Flesch-Kincaid score ipv FLOAT Information processing score for visual content ipa FLOAT Information processing score for auditory content ipt FLOAT Information processing score for textual content wmv FLOAT Working memory score for visual content wma FLOAT Working memory score for auditory content wmt FLOAT Working memory score for textual content attempt SMALL INT Indicates whether mdl_poll_user.py has generated a path for the user Table: mdl_questions Field Data Type Description id INT (AUTO INCREMENT) Auto increment identifier questiontext TEXT Text of the question generalfeedback TEXT Feedback to be given with solution qtype TEXT Indicates question type – multichoice / truefalse Table: mdl_question_answers Field Data Type Description id INT (AUTO INCREMENT) Auto increment identifier question INT Foreign key – ID in mdl_questions answer TEXT Choices for the question fraction FLOAT Score of the choice Table: mdl_question_versions Field Data Type Description id INT (AUTO INCREMENT) Auto increment identifier questionbankentryid INT Foreign key – ID in mdl_question_bank_entries questionid INT Foreign key – ID in mdl_questions Table: mdl_question_bank_entries Field Data Type Description id INT (AUTO INCREMENT) Auto increment identifier questioncategoryid INT Category of the question in the question bank fyp Table: topics Field Data Type Description id INT (AUTO INCREMENT) Auto increment identifier topic_name VARCHAR Name of the topic difficulty FLOAT Difficulty value of the topic num_questions INT Number of quiz questions to be given for topic Table: lo Field Data Type Description id INT (AUTO INCREMENT) Auto increment identifier topic INT Foreign key – ID in topics v FLOAT Visual score a FLOAT Auditory score t FLOAT Textual score ip FLOAT Information processing score read_metric FLOAT Readability score path TEXT Path to the resource in the server Table: clusters Field Data Type Description id INT (AUTO INCREMENT) Auto increment identifier centroid LONG TEXT Centroid of the cluster as an array gene_pool LONG TEXT Gene pool of the cluster as JSON Table: students Field Data Type Description user_id INT Foreign key – ID in mdl_user path LONG TEXT Current learning pathway of the student cluster_id INT Foreign key – ID of clusters difficulty LONG TEXT Difficulty values topic-wise as JSON gene_space LONG TEXT Gene space of the student as JSON explored_genes LONG TEXT Genes explored by GA in ascending order of cost, arranged topic-wise learning_costs LONG TEXT Genes and their learning costs for the student as JSON completed LONG TEXT Topics completed by the student as an array stored_path LONG TEXT Initial learning path generated for the student Table: quiz_attempts Field Data Type Description student_id INT Foreign key – ID in mdl_user topic_id INT Foreign key – ID in topics attempts INT Quiz attempts of the user on the given topic scores LONG TEXT Scores obtained by the student in quiz attempts (JSON) ","moodle#moodle":""},"title":"Databases"},"/docs/file-system/":{"data":{"":"","#":"The following files manage the complete process of generating the personalized learning path and delivering it to the student. These are encapsulated within the learningpath folder, which contains a custom Moodle plugin developed to provide the necessary functionalities.\nTable: Files File name Path/folder Input Function GA_functions.py moodle/local/learningpath None Contains all GA-related and database access functions script.py moodle/local/learningpath User id Generates a personalized learning path for the given user and stores the values in table students mdl_poll_user.py moodle/local/learningpath None Triggers script.py when profile scores are updated in mdl_user Quizupdate.py moodle/local/learningpath User id, topic id, score Modifies the learning path after a quiz is completed and stores the updated path in students scoring.py moodle/local/learningpath User id, topic id, score Updates the quiz scores in table quiz_attempts view.php moodle/local/learningpath Moodle user login Displays course content to the student get_next_lo.py moodle/local/learningpath User id Fetches the next LO for the user from table students quiz.php moodle/local/learningpath Moodle session data Displays quiz for the previously taught topic quiz_submit.php moodle/local/learningpath Moodle session data Calculates quiz score and displays solutions get_quiz_questions.py moodle/local/learningpath Topic id Fetches topic-wise questions from mdl_question, mdl_question_versions, and mdl_question_bank_entries dashboard.php moodle/local/learningpath Moodle user login Displays graphical learning style score distribution get_dashboard_data.py moodle/local/learningpath User id Fetches user learning style scores for the dashboard progress.php moodle/local/learningpath Moodle user login Displays progress using quiz attempts and scores get_progress_data.py moodle/local/learningpath User id Fetches data about quiz attempts and scores "},"title":"File System"},"/docs/file-system/displaying-learning-object/":{"data":{"":"","get_next_lopy#get_next_lo.py":"","viewphp#view.php":"get_next_lo.py #get_next_lo.py import pymysql import json import sys import variables user_id = int(sys.argv[1]) conn = pymysql.connect( host=variables.HOST, user=variables.USER, password=variables.PASS, database='fyp' ) cursor = conn.cursor() # Get path from student table cursor.execute(\"SELECT path FROM students WHERE user_id = %s\", (user_id,)) result = cursor.fetchone() if not result: print(json.dumps({\"path\": \"none\"})) exit() path_str = result[0] path = json.loads(path_str) if not path: print(json.dumps({\"path\": \"none\"})) exit() next_lo = path.pop(0) # Fetch LO path and topic_id from lo table cursor.execute(\"SELECT path, topic FROM lo WHERE id = %s\", (next_lo,)) lo_result = cursor.fetchone() if not lo_result: print(json.dumps({\"path\": \"none\"})) conn.close() exit() lo_path, topic_id = lo_result # Fetch topic name using topic_id cursor.execute(\"SELECT topic_name FROM topics WHERE id = %s\", (topic_id,)) topic_result = cursor.fetchone() conn.close() topic_name = topic_result[0] if topic_result else \"Unknown Topic\" # Output both path and topic name print(json.dumps({ \"path\": lo_path, \"topic_id\": topic_id, \"topic_name\": topic_name })) view.php # view.php \u003c?php require_once('../../config.php'); require_login(); $userid = $USER-\u003eid; // Run Python script $command = \"python3 /var/www/html/moodle/local/learningpath/get_next_lo.py $userid 2\u003e\u00261\"; $output = shell_exec($command); if (!$output) { echo \"Error: Python script did not return anything.\u003cbr\u003e\"; exit; } $result = json_decode($output, true); // Extract and store values $path = $result['path'] ?? null; $topic_id = $result['topic_id'] ?? null; $topic_name = $result['topic_name'] ?? null; $_SESSION['topic_id'] = $topic_id; $_SESSION['topic_name'] = $topic_name; if (!$path || $path === \"none\") { echo ' \u003cdiv style=\"display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; text-align: center;\"\u003e \u003ch3 style=\"font-size: 36px; color: #4CAF50; margin-bottom: 20px;\"\u003eCourse completed! Thank you for taking it! 🎉\u003c/h3\u003e \u003ca href=\"/moodle/course/view.php?id=2\" style=\"font-size: 18px; color: white; background-color: #007bff; padding: 12px 24px; text-decoration: none; border-radius: 5px;\"\u003e ⬅️ Return to Moodle \u003c/a\u003e \u003c/div\u003e'; exit; } // Display topic title centered in dark blue, bold echo \"\u003cdiv style='width: 100%; text-align: center; margin: 30px 0 20px;'\u003e \u003ch3 style='color: #003366; font-weight: bold; font-size: 32px;'\u003e 📝 $topic_name \u003c/h3\u003e \u003c/div\u003e\"; $file_extension = strtolower(pathinfo($path, PATHINFO_EXTENSION)); if ($file_extension === 'txt') { $content = @file_get_contents($path); if ($content === false) { echo \"\u003cp style='color: red; text-align: center;'\u003eFailed to load content.\u003c/p\u003e\"; } else { echo \"\u003cdiv style='margin: 0 auto; max-width: 900px; padding: 40px; background-color: #dbf3ff; border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.1); font-family: Georgia, serif; font-size: 18px; line-height: 1.8; color: #333;'\u003e \" . nl2br(htmlspecialchars($content)) . \" \u003c/div\u003e\"; } } elseif ($file_extension === 'mp4') { echo \"\u003cdiv style='display: flex; justify-content: center;'\u003e \u003cvideo controls style='width: 90%; max-width: 960px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);'\u003e \u003csource src='$path' type='video/mp4'\u003e Your browser does not support the video tag. \u003c/video\u003e \u003c/div\u003e\"; } else { echo \"\u003ciframe src='$path' style='width: 100vw; height: calc(100vh - 250px); border: none; display: block; margin: 0 auto;'\u003e\u003c/iframe\u003e\"; } // Proceed to Quiz button styled and spaced echo \"\u003cdiv style='text-align: center; margin-top: 40px;'\u003e \u003ca href='quiz.php'\u003e \u003cbutton style='background-color: #0056b3; color: white; padding: 14px 28px; font-size: 18px; border: none; border-radius: 6px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1);'\u003e ➡️ Proceed to Quiz \u003c/button\u003e \u003c/a\u003e \u003c/div\u003e\"; ?\u003e "},"title":"Display learning content"},"/docs/file-system/initial-path-generation/":{"data":{"":"Once the profiling assessment is completed, the code provided below triggers the path generation script, utilizing the obtained profiling scores to personalize the learning path.\n# poll_mdl_user.py import pymysql import time import subprocess from datetime import datetime import variables # Store last seen timestamps last_seen = {} def fetch_updated_users(): conn = pymysql.connect( host=variables.HOST, user=variables.USER, password=variables.PASS, database='moodle' ) cursor = conn.cursor() cursor.execute(\"SELECT id, last_profile_update FROM mdl_user WHERE attempt = 0\") users = cursor.fetchall() conn.close() return users def scores_available(user_id): \"\"\"Checks if all required scores are available (not NULL) for the user.\"\"\" conn = pymysql.connect( host=variables.HOST, user=variables.USER, password=variables.PASS, database='moodle' ) cursor = conn.cursor() cursor.execute(\"\"\" SELECT wmv, wma, wmt, ipv, ipa, ipt, flesch FROM mdl_user WHERE id = %s \"\"\", (user_id,)) result = cursor.fetchone() conn.close() if result is None: return False return all(score is not None for score in result) def mark_attempt_done(user_id): conn = pymysql.connect( host=variables.HOST, user=variables.USER, password=variables.PASS, database='moodle' ) cursor = conn.cursor() cursor.execute(\"UPDATE mdl_user SET attempt = 1 WHERE id = %s\", (user_id,)) conn.commit() conn.close() def main(): while True: print(\"Polling for updates...\") updated_users = fetch_updated_users() for user_id, last_update in updated_users: if user_id not in last_seen or (last_update and last_update \u003e last_seen[user_id]): if scores_available(user_id): print(f\"[INFO] Detected update with scores for user {user_id}, running script.py\") subprocess.Popen([\"python3\", \"script.py\", str(user_id)]) last_seen[user_id] = last_update mark_attempt_done(user_id) else: print(f\"[WARN] Update detected for user {user_id}, but scores incomplete.\") time.sleep(30) # Poll every 30 seconds if __name__ == \"__main__\": main() Download poll_mdl_user.py from here\nThe functions related to the Genetic Algorithm, along with commonly used database operations, are consolidated in the GA_functions.py file.\n# GA_functions.py import pygad import pymysql import random import json import numpy as np import copy from collections import OrderedDict from typing import OrderedDict import variables import warnings warnings.filterwarnings(\"ignore\", category=UserWarning, module=\"pygad\") class LO: def __init__(self, id, topic, v, a, t, ip, read_metric): self.id = id self.topic = topic self.v = v # Visual metric self.a = a # Auditory metric self.t = t # Reading/Writing metric self.ip = ip # Information processing metric self.read_metric = read_metric # readability score of content (r) def __repr__(self): return f\"{self.id}({self.topic})\" class student: def __init__(self, id, wma, wmv, wmt, ipa, ipv, ipt, read_metric, cluster_id, difficulty_val, gene_space, completed, learning_costs, genes_explored): self.id = id self.wmv = wmv self.wma = wma self.wmt = wmt self.ipv = ipv self.ipa = ipa self.ipt = ipt self.read_metric = read_metric #rd - readability score self.s = wma + wmv + wmt + ipa + ipv + ipt if (self.s==0): self.v = 0 self.a = 0 self.t = 0 else: self.v = (wmv + ipv)/self.s self.a = (wma + ipa)/self.s self.t = (wmt + ipt)/self.s self.cluster_id= cluster_id self.difficulty= copy.deepcopy(difficulty_val) self.gene_space=copy.deepcopy(gene_space) self.completed=copy.deepcopy(completed) self.learning_costs=copy.deepcopy(learning_costs) self.explored_genes= copy.deepcopy(genes_explored) def __repr__(self): return f\"{self.id}\" class Cluster: def __init__(self, centroid): self.centroid = centroid # [v, a, t] self.gene_pool = set() # Set of unique genes in the cluster def __repr__(self): return f\"{self.centroid}\\n{self.gene_pool}\" #Generating a random chromosome def generate_random_chromosome(grouped_los): chromosome = [random.choice(grouped_los[topic]) for topic in grouped_los] random.shuffle(chromosome) return np.array(chromosome, dtype=int) def generate_initial_population(pop_size, grouped_los): return np.array([generate_random_chromosome(grouped_los) for _ in range(pop_size)]) def add_learning_cost(topic, gene, cost, student_profile): explored_genes= student_profile.explored_genes # If topic does not exist, create an empty dictionary for it if topic not in explored_genes: explored_genes[topic] = {} # Add gene-cost pair only if gene is not already present if gene not in explored_genes[topic]: explored_genes[topic][gene] = cost explored_genes[topic] = OrderedDict(sorted(explored_genes[topic].items(), key=lambda x: x[1])) def fitness_function(random_chromosome, student_profile, learning_objects): lc = 0 lgs = [] n = len(random_chromosome) # Ensure random_chromosome is treated as a list of integers random_chromosome = random_chromosome.astype(int) for i in random_chromosome: lg = learning_cost(i, student_profile, learning_objects) lgs.append(lg) lc = sum(lgs) / n '''local_learning_costs = [ (lgs[i - 1] + lgs[i]) / 2 for i in range(1, n) ] variance = sum([(l - lc) ** 2 for l in local_learning_costs]) fitness_value = lc + variance''' fitness_value= lc return -fitness_value def learning_cost(i, student_profile, learning_objects): lo = learning_objects[i] # Get the LO object from the dictionary learning_costs = student_profile.learning_costs topic = lo.topic if i in learning_costs and learning_costs[i] != -1: return learning_costs[i] else: wr = 0 rd = student_profile.read_metric r = lo.read_metric d = student_profile.difficulty[topic] if rd \u003e= r: wr = (rd - r) / 20 s = student_profile.s v, a, t = student_profile.v, student_profile.a, student_profile.t tc, ac, vc = lo.t, lo.a, lo.v wip = 1 - (s / 33) ip = lo.ip lg = d + wr + t * (5 - tc) + a * (5 - ac) + v * (5 - vc) + wip * ip learning_costs[i] = lg add_learning_cost(topic, i, lg, student_profile) return lg def pmx_crossover(parents, offspring_size, learning_objects): offspring = [] parents = parents.tolist() # Convert numpy array to list for processing for _ in range(offspring_size[0]): # Randomly select two parents parent1, parent2 = random.sample(parents,2) # Randomly choose crossover points size = len(parent1) point1, point2 = sorted(random.sample(range(size), 2)) # Initialize offspring with placeholders child = [-1] * size # Copy segment from parent1 to the child child[point1:point2 + 1] = parent1[point1:point2 + 1] # Track topics already in the crossed section used_topics = {learning_objects[int(gene)].topic for gene in child[point1:point2 + 1] if gene != -1} # Add genes from parent2 that do not duplicate topics in the crossed section for idx in range(size): if idx \u003c point1 or idx \u003e point2: # Consider only indices outside the crossed section candidate = parent2[idx] candidate_topic = learning_objects[int(candidate)].topic if candidate_topic not in used_topics: child[idx] = candidate used_topics.add(candidate_topic) # Fill any remaining empty slots (`-1`) with unused genes from parent2 for idx in range(size): if child[idx] == -1: for candidate in parent2: candidate_topic = learning_objects[int(candidate)].topic if candidate_topic not in used_topics: child[idx] = candidate used_topics.add(candidate_topic) break # Append the generated child to the offspring list offspring.append(child) # Convert offspring to a numpy array before returning return np.array(offspring) def mutate_gene(solution, mutation_probability, student_profile, learning_objects): if np.random.rand() \u003c mutation_probability: # Apply mutation based on probability # Pick a random index in the solution idx = np.random.randint(0, len(solution)) current_gene = solution[idx] current_topic = learning_objects[int(current_gene)].topic # Replace with a random LO of the same topic solution[idx] = random.choice(student_profile.gene_space[current_topic]) return solution def mutation(offspring, ga_instance, student_profile, learning_objects): mutation_probability = ga_instance.prob # Example mutation probability for idx in range(offspring.shape[0]): # Iterate over each chromosome # Apply custom mutation logic for the chromosome offspring[idx] = mutate_gene( solution=offspring[idx], mutation_probability=mutation_probability, student_profile= student_profile, learning_objects= learning_objects ) return offspring def repair(chromosome, dependency_graph, learning_objects, student_profile): # Convert chromosome to a list for processing chromosome = chromosome.tolist() # Extract topics from the chromosome topics = [learning_objects[int(gene)].topic for gene in chromosome] # Perform a topological sort on the dependency graph in_degree = {topic: 0 for topic in dependency_graph} for deps in dependency_graph.values(): for dep in deps: in_degree[dep] += 1 # Queue for topics with no dependencies queue = [topic for topic in in_degree if in_degree[topic] == 0] topo_sort = [] while queue: # Sort the queue by difficulty from the student's perspective queue.sort(key=lambda topic: student_profile.difficulty.get(topic, float('inf'))) # Pop the topic with the lowest difficulty topic = queue.pop(0) topo_sort.append(topic) for dependent in dependency_graph[topic]: in_degree[dependent] -= 1 if in_degree[dependent] == 0: queue.append(dependent) # Map topics to their position in the topological order topic_to_index = {topic: i for i, topic in enumerate(topo_sort)} # Reorder the chromosome to match the topological order repaired_chromosome = sorted(chromosome, key=lambda gene: topic_to_index[learning_objects[int(gene)].topic]) # Convert back to NumPy array and return return np.array(repaired_chromosome) def on_generation(ga_instance, learning_objects, student_profile): #Functions to be performed at the end of every generation # Access the population population = ga_instance.population # Dependency graph dependency_graph = { 27: [28, 32], 28: [29, 30], 29: [31], 30: [31], 32: [33], 33: [34], 34: [35], 31: [], 35: [] } # Repair each chromosome in the population for i in range(len(population)): population[i] = repair(population[i], dependency_graph, learning_objects, student_profile) # Update the population in the GA instance ga_instance.population = population best_solution, best_fitness, _ = ga_instance.best_solution() global max_fitness, sol, avg_fitness, c c=c+1 avg_fitness=avg_fitness+best_fitness if(max_fitness\u003c best_fitness): max_fitness= best_fitness sol= best_solution def fitness_function_wrapper(ga_instance, solution, solution_idx): return fitness_function(solution, variables.student_profile, variables.learning_objects) def pmx_crossover_wrapper(parents, offspring_size, ga_instance): return pmx_crossover(parents, offspring_size, variables.learning_objects) def mutation_wrapper(offspring, ga_instance): return mutation(offspring, ga_instance, variables.student_profile, variables.learning_objects) def on_generation_wrapper(ga_instance): on_generation(ga_instance, variables.learning_objects, variables.student_profile) def cluster_assignment(student_profile, clusters, max_distance): # Assumes no cluster assigned previously to the student student_vat = np.array([student_profile.v, student_profile.a, student_profile.t]) assigned = False # Find the closest cluster within max_distance for cluster_id, cluster in clusters.items(): # Iterate through dictionary # Manhattan distance distance = np.sum(np.abs(student_vat - cluster.centroid)) print(\"distance:\",distance) if distance \u003c= max_distance: # Update cluster.centroid = np.mean([cluster.centroid] + [student_vat], axis=0) student_profile.cluster_id = cluster_id # Assign cluster ID to the student assigned = True num_gen=500 break # If no suitable cluster, create a new one if not assigned: new_cluster_id = max(clusters.keys(), default=0) + 1 # Get new cluster ID clusters[new_cluster_id] = Cluster(centroid=student_vat) # Initialize new cluster student_profile.cluster_id = new_cluster_id # Assign new cluster ID num_gen=1000 return num_gen def get_initial_population(student_profile, clusters): # Gene space of student is assumed to contain at least one gene for each topic # Grouped_los and learning objects are universal ones cluster = clusters.get(int(student_profile.cluster_id)) # Retrieve cluster safely if cluster is None: return None # Handle missing cluster case gene_pool = cluster.gene_pool gene_space = student_profile.gene_space grouped_genes = {} for topic, genes in gene_space.items(): grouped_genes[topic] = [gene for gene in genes if int(gene) in gene_pool] if not grouped_genes[topic]: grouped_genes[topic] = genes # Use all genes if no match in gene pool return generate_initial_population(16, grouped_genes) def generate_path(student_profile, initial_pop, num_gen): global max_fitness, avg_fitness, c, sol max_fitness = float('-inf') avg_fitness = 0 c = 0 ga_instance = pygad.GA( initial_population=initial_pop, num_generations=num_gen, num_parents_mating=10, fitness_func=fitness_function_wrapper, sol_per_pop=16, parent_selection_type='rws', crossover_type=pmx_crossover_wrapper, mutation_type=mutation_wrapper, on_generation=on_generation_wrapper, keep_elitism=1 ) ga_instance.prob = 0.7 ga_instance.run() # Best solution best_solution, best_fitness, _ = ga_instance.best_solution() avg_fitness += best_fitness c += 1 avg_fitness /= c if best_fitness \u003e max_fitness: max_fitness = best_fitness sol = best_solution return sol def add_path(student_profile, path, clusters): cluster = clusters.get(int(student_profile.cluster_id)) # Retrieve cluster safely if cluster: cluster.gene_pool.update(path) # Update gene pool def get_path(student_profile, clusters, max_distance, num_gen): if student_profile.cluster_id is None: num_gen=cluster_assignment(student_profile, clusters, max_distance) # If assigned is false =\u003e then new cluster created initial_pop = get_initial_population(student_profile, clusters) '''print(\"Initial population:\") print(initial_pop)''' path = generate_path(student_profile, initial_pop, num_gen) add_path(student_profile, path, clusters) return path def update_gene(path, student_curr, topic): explored_genes = student_curr.explored_genes[topic] path[0] = next(iter(explored_genes)) return path def update_score(student_curr, score, true_attempts, path, clusters, max_distance, learning_objects): attempts= true_attempts%3 topic = learning_objects[int(path[0])].topic topic_name=fetch_topic_name(topic) # Test passed if score \u003e= 0.8: del student_curr.gene_space[topic] del student_curr.explored_genes[topic] student_curr.completed.append(topic) print(topic_name, \"completed!\") new_path = np.delete(path, 0) # End of course if len(new_path): store_attempt(student_curr.id, learning_objects[new_path[0]].topic, 1) #print(\"Course completed!\") return new_path else: #remove the gene print(\"Oops! Retry\", topic_name) student_curr.gene_space[topic].remove(int(path[0])) del student_curr.explored_genes[topic][int(path[0])] if not student_curr.gene_space[topic] or not student_curr.explored_genes[topic]: print(\"No more resources available on\", topic_name, \"!\") del student_curr.gene_space[topic] del student_curr.explored_genes[topic] student_curr.completed.append(topic) new_path=np.delete(path, 0) if len(new_path): store_attempt(student_curr.id, learning_objects[new_path[0]].topic, 1) #print(\"Course completed!\") return new_path else: if (attempts==1 or attempts==2): #print(\"updating gene\") new_path= update_gene(path, student_curr, topic) store_attempt(student_curr.id, learning_objects[new_path[0]].topic, true_attempts+1) return new_path else: #print(\"regenerating path with increased difficulty for the topic\") d=student_curr.difficulty[topic] #print(\"previous difficulty:\", d) d=d+(1-score) if(d\u003e5): d=5 #print(\"updated difficulty:\", d) student_curr.difficulty[topic]=d if(len(path)==1): new_path= update_gene(path, student_curr,topic) # only 1 gene needs to be updated not the whole path store_attempt(student_curr.id, learning_objects[new_path[0]].topic, true_attempts+1) else: ''' fetch existing attempts and update either with 1 if new topic or attempts+1 for same topic or attempts'+1 for revisit''' new_path= get_path(student_curr,clusters, max_distance, variables.num_regen) new_topic=learning_objects[new_path[0]].topic if(topic==new_topic): store_attempt(student_curr.id, new_topic, true_attempts+1) else: new_attempt= fetch_attempts(student_curr.id, new_topic) store_attempt(student_curr.id, new_topic, new_attempt+1) return new_path def fetch_learning_objects(): import pymysql conn = pymysql.connect(host=variables.HOST, user=variables.USER, password=variables.PASS, database=\"fyp\") cursor = conn.cursor() # Join `lo` and `topics` on the topic column, and fetch the IP from topics cursor.execute(\"\"\" SELECT lo.id, lo.topic, lo.v, lo.a, lo.t, topics.ip, lo.read_metric FROM lo JOIN topics ON lo.topic = topics.id; \"\"\") rows = cursor.fetchall() conn.close() # Store learning objects in a dictionary learning_objects = {row[0]: LO(*row) for row in rows} # Group learning object IDs by topic grouped_los = {} for lo_id, lo in learning_objects.items(): if lo.topic not in grouped_los: grouped_los[lo.topic] = [] grouped_los[lo.topic].append(lo_id) return learning_objects, grouped_los def fetch_clusters(): #print(\"Fetching clusters...\") try: conn = pymysql.connect( host=variables.HOST, user=variables.USER, password=variables.PASS, database=\"fyp\" ) #print(\"Connection established.\") except Exception as conn_err: print(\"Database connection error:\", conn_err) return {} try: cursor = conn.cursor() #print(\"Cursor created.\") try: cursor.execute(\"SELECT id, centroid, gene_pool FROM clusters;\") rows = cursor.fetchall() #print(f\"Fetched {len(rows)} rows from clusters.\") except Exception as query_err: print(\"Error executing SELECT query:\", query_err) return {} finally: cursor.close() #print(\"Cursor closed.\") except Exception as cursor_err: print(\"Cursor error:\", cursor_err) return {} finally: conn.close() #print(\"Connection closed.\") clusters = {} for row in rows: try: cluster_id = row[0] centroid = np.array(json.loads(row[1])) gene_pool = set(np.int64(x) for x in json.loads(row[2])) clusters[cluster_id] = Cluster(centroid) clusters[cluster_id].gene_pool=gene_pool except Exception as parse_err: print(f\"Error parsing cluster row {row}: {parse_err}\") return clusters def store_clusters(clusters): \"\"\"Stores or updates clusters in the database.\"\"\" try: conn = pymysql.connect( host=variables.HOST, user=variables.USER, password=variables.PASS, database=\"fyp\" ) cursor = conn.cursor() for cluster_id, cluster_obj in clusters.items(): centroid_json = json.dumps(convert_np(cluster_obj.centroid)) gene_pool_json = json.dumps(convert_np(list(cluster_obj.gene_pool))) cursor.execute(\"\"\" INSERT INTO clusters (id, centroid, gene_pool) VALUES (%s, %s, %s) ON DUPLICATE KEY UPDATE centroid = VALUES(centroid), gene_pool = VALUES(gene_pool); \"\"\", (cluster_id, centroid_json, gene_pool_json)) conn.commit() except Exception as e: print(\"Error while storing clusters:\", e) finally: conn.close() def fetch_difficulty_values(): conn = pymysql.connect(host=variables.HOST, user=variables.USER, password=variables.PASS, database=\"fyp\") cursor = conn.cursor() cursor.execute(\"SELECT id, difficulty FROM topics;\") rows = cursor.fetchall() conn.close() return {row[0]: row[1] for row in rows} def fetch_topic_name(topic_id): conn = pymysql.connect(host=variables.HOST, user=variables.USER, password=variables.PASS, database=\"fyp\") cursor = conn.cursor() cursor.execute(\"SELECT topic_name FROM topics where id=%s;\", topic_id) rows = cursor.fetchone() conn.close() return rows[0] def fetch_student_profile(user_id): \"\"\"Fetch student profile from the database.\"\"\" conn = pymysql.connect(host=variables.HOST, user=variables.USER, password=variables.PASS, database=\"moodle\") cursor = conn.cursor() cursor.execute(\"SELECT wmv, wma, wmt, ipv, ipa, ipt, flesch FROM mdl_user WHERE id=%s\", (user_id,)) student_data = cursor.fetchone() conn.close() conn = pymysql.connect(host=variables.HOST, user=variables.USER, password=variables.PASS, database=\"fyp\") cursor = conn.cursor() cursor.execute(\"SELECT path, difficulty, gene_space, explored_genes, completed, learning_costs, cluster_id FROM students WHERE user_id=%s\", (user_id,)) student_details = cursor.fetchone() conn.close() if not student_data or not student_details: print(\"Error: Student profile not found.\") return None # Parse JSON fields path = json.loads(student_details[0]) raw_difficulties = json.loads(student_details[1]) difficulties= {int(k): v for k,v in raw_difficulties.items()} gene_space_raw = json.loads(student_details[2]) gene_space = {int(k): v for k, v in gene_space_raw.items()} # Convert back from JSON list to Python objects explored_genes_raw = json.loads(student_details[3]) explored_genes = {int(k): {int(sub_k): v for sub_k, v in sub_dict.items()} for k, sub_dict in explored_genes_raw.items()} completed_raw = student_details[4] completed = json.loads(completed_raw) if completed_raw else [] learning_costs_raw = json.loads(student_details[5]) learning_costs = {int(k): float(v) for k, v in learning_costs_raw.items()} cluster_id = int(student_details[6]) student_profile= student( id=user_id, wmv=student_data[0], wma=student_data[1], wmt=student_data[2], ipv=student_data[3], ipa=student_data[4], ipt=student_data[5], read_metric=student_data[6], difficulty_val=difficulties, gene_space=gene_space, completed= completed, learning_costs= learning_costs, genes_explored=explored_genes, cluster_id=cluster_id ) return student_profile, path def store_student_profile(user_id, student_profile, path): \"\"\"Update student profile in the database.\"\"\" # Store in Moodle DB the path and cluster assigned conn = pymysql.connect(host=variables.HOST, user=variables.USER, password=variables.PASS, database=\"fyp\") cursor = conn.cursor() path_json = json.dumps(path, default=convert_np) query = \"\"\" INSERT INTO students (user_id, path, stored_path, cluster_id, difficulty, gene_space, explored_genes, learning_costs, completed) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE path = VALUES(path), stored_path = VALUES(stored_path), cluster_id = VALUES(cluster_id), difficulty = VALUES(difficulty), gene_space = VALUES(gene_space), explored_genes = VALUES(explored_genes), learning_costs = VALUES(learning_costs), completed = VALUES(completed); \"\"\" try: cursor.execute(query, ( user_id, path_json, path_json, convert_np(student_profile.cluster_id), # Just in case it's also a numpy type json.dumps(student_profile.difficulty), json.dumps(student_profile.gene_space), json.dumps(convert_np(student_profile.explored_genes)), json.dumps(convert_np(student_profile.learning_costs)), json.dumps(student_profile.completed) )) conn.commit() #print(f\"[INFO] Successfully updated student profile for user_id={user_id}\") except Exception as e: print(f\"[ERROR] Failed to update student profile for user_id={user_id}: {e}\") conn.close() def update_student_profile(user_id, student_profile, path): \"\"\"Update student profile in the database.\"\"\" # Store in Moodle DB the path and cluster assigned conn = pymysql.connect(host=variables.HOST, user=variables.USER, password=variables.PASS, database=\"fyp\") cursor = conn.cursor() path_json = json.dumps(path, default=convert_np) query = \"\"\" INSERT INTO students (user_id, path, cluster_id, difficulty, gene_space, explored_genes, learning_costs, completed) VALUES (%s, %s, %s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE path = VALUES(path), cluster_id = VALUES(cluster_id), difficulty = VALUES(difficulty), gene_space = VALUES(gene_space), explored_genes = VALUES(explored_genes), learning_costs = VALUES(learning_costs), completed = VALUES(completed); \"\"\" try: cursor.execute(query, ( user_id, path_json, convert_np(student_profile.cluster_id), # Just in case it's also a numpy type json.dumps(student_profile.difficulty), json.dumps(student_profile.gene_space), json.dumps(convert_np(student_profile.explored_genes)), json.dumps(convert_np(student_profile.learning_costs)), json.dumps(student_profile.completed) )) conn.commit() #print(f\"[INFO] Successfully updated student profile for user_id={user_id}\") except Exception as e: print(f\"[ERROR] Failed to update student profile for user_id={user_id}: {e}\") conn.close() def fetch_attempts(user_id, topic_id): \"\"\"Fetch the number of quiz attempts for a specific topic by a student.\"\"\" conn = pymysql.connect(host=variables.HOST, user=variables.USER, password=variables.PASS, database=\"fyp\") cursor = conn.cursor() cursor.execute(\"SELECT attempts FROM quiz_attempts WHERE student_id=%s AND topic_id=%s\", (user_id, topic_id)) result = cursor.fetchone() conn.close() return result[0] if result else 0 # Default to 0 if no attempts recorded def store_attempt(user_id, topic_id, attempts): \"\"\"Store or update the number of quiz attempts for a specific topic by a student.\"\"\" try: conn = pymysql.connect( host=variables.HOST, user=variables.USER, password=variables.PASS, database=\"fyp\" ) cursor = conn.cursor() query = \"\"\" INSERT INTO quiz_attempts (student_id, topic_id, attempts) VALUES (%s, %s, %s) ON DUPLICATE KEY UPDATE attempts = VALUES(attempts); \"\"\" cursor.execute(query, (user_id, topic_id, attempts)) conn.commit() except Exception as e: print(f\"Error storing attempts for user_id={user_id}, topic_id={topic_id}: {e}\") finally: conn.close() def convert_np(obj): if isinstance(obj, dict): return {convert_np(k): convert_np(v) for k, v in obj.items()} elif isinstance(obj, list): return [convert_np(i) for i in obj] elif isinstance(obj, np.integer): return int(obj) elif isinstance(obj, np.floating): return float(obj) elif isinstance(obj, np.ndarray): return obj.tolist() else: return obj Download GA_functions.py from here\nThe script below, triggered by mdl_poll_user.py, generates a personalized learning path by retrieving profiling assessment scores from the database and utilizing the Genetic Algorithm functions defined in the GA_functions.py file.\n# script.py from GA_functions import * import variables def generate_learning_path(user_id): user_id=int(user_id) \"\"\"Generates a learning path and stores it in Moodle.\"\"\" print(\"here\") # Fetch learning objects learning_objects, grouped_los = fetch_learning_objects() # Fetch learning objects variables.learning_objects= learning_objects print(\"learning objects\",variables.learning_objects) # Fetch difficulty values dynamically difficulty_val = fetch_difficulty_values() print(\"difficulty_val\",difficulty_val) # Fetch clusters clusters = fetch_clusters() print(\"clusters:\", clusters) # Fetch student's cognitive profile from mdl_user conn = pymysql.connect(host=variables.HOST, user=variables.USER, password=variables.PASS, database=\"moodle\") print(\"connected\") print(\"userid\", user_id) cursor = conn.cursor() print(\"going to execute\") cursor.execute(\"SELECT wmv, wma, wmt, ipv, ipa, ipt, flesch FROM mdl_user WHERE id=%s;\", (user_id,)) print(\"executed\") student_data = cursor.fetchone() print(\"student data:\", student_data) conn.close() if not student_data: print(\"not found\") return {\"error\": \"Student profile not found\"} print(\"student profile found\") student_profile = student( id=user_id, wmv=student_data[0], wma=student_data[1], wmt=student_data[2], ipv=student_data[3], ipa=student_data[4], ipt=student_data[5], read_metric=student_data[6], cluster_id=None, difficulty_val=difficulty_val, gene_space=grouped_los, completed=[], learning_costs={}, genes_explored={} ) variables.student_profile= student_profile print(variables.student_profile) print(variables.max_distance, variables.num_gen) best_solution = get_path(student_profile, clusters, variables.max_distance, variables.num_gen) print(\"best_solution:\",best_solution) print(clusters) # Store updated clusters store_clusters(clusters) # Convert learning path to JSON format for storage learning_path = [int(i) for i in best_solution] store_student_profile(user_id, student_profile, learning_path) store_attempt(user_id, learning_objects[learning_path[0]].topic, 1) return {\"message\": \"Learning path generated\", \"path\": learning_path} if __name__ == \"__main__\": import sys import logging print(\"Script has started running\") #logging.basicConfig(filename='/tmp/script_debug.log', level=logging.DEBUG) try: userid = sys.argv[1] #logging.debug(f\"Script started for user: {userid}\") print(\"hello world\") print(userid) result = generate_learning_path(userid) print(result) except Exception as e: #logging.exception(\"An error occurred:\") if len(sys.argv) \u003c 2: print(\"Usage: script.py \u003cuserid\u003e\") sys.exit(0) Download script.py from here"},"title":"Path Generation Script"},"/docs/file-system/quizzes-and-path-updation/":{"data":{"":"","get_quiz_questionspy#get_quiz_questions.py":"","quiz_submitphp#quiz_submit.php":"","quizphp#quiz.php":"","quizupdatepy#Quizupdate.py":"","scoringpy#scoring.py":"get_quiz_questions.py #get_quiz_questions.py import pymysql import json import sys import variables import random topic_id = int(sys.argv[1]) # Step 1: Fetch topic name and num_questions from 'fyp.topics' try: conn_fyp = pymysql.connect( host=variables.HOST, user=variables.USER, password=variables.PASS, database='fyp' ) cursor_fyp = conn_fyp.cursor() cursor_fyp.execute(\"SELECT topic_name, num_questions FROM topics WHERE id = %s\", (topic_id,)) topic_data = cursor_fyp.fetchone() if not topic_data: raise Exception(\"Topic not found in fyp.topics\") topic_name, num_questions = topic_data category_id = int(topic_id) - 18 #mapping between topic and question bank category cursor_fyp.close() conn_fyp.close() except Exception as e: print(json.dumps({\"error\": f\"Error fetching topic info: {str(e)}\"})) sys.exit() # Step 2: Fetch questions and options from Moodle DB try: conn_moodle = pymysql.connect( host=variables.HOST, user=variables.USER, password=variables.PASS, database='moodle' ) cursor = conn_moodle.cursor() query = \"\"\" SELECT q.id, q.questiontext, q.qtype, q.generalfeedback FROM mdl_question q JOIN mdl_question_versions v ON q.id = v.questionid JOIN mdl_question_bank_entries e ON v.questionbankentryid = e.id WHERE e.questioncategoryid = %s ORDER BY RAND() \"\"\" cursor.execute(query, (category_id, )) questions_raw = cursor.fetchall() questions = [] for qid, text, qtype, feedback in questions_raw: question = { \"id\": qid, \"text\": text, \"type\": qtype, \"feedback\":feedback, \"options\": [] } if qtype == \"multichoice\": cursor.execute(\"SELECT answer, fraction FROM mdl_question_answers WHERE question = %s\", (qid,)) for answer, fraction in cursor.fetchall(): question[\"options\"].append({ \"text\": answer, \"is_correct\": fraction \u003e 0 }) elif qtype == \"truefalse\": cursor.execute(\"SELECT answer, fraction FROM mdl_question_answers WHERE question = %s\", (qid,)) for answer, fraction in cursor.fetchall(): question[\"options\"].append({ \"text\": answer, \"is_correct\": fraction \u003e 0 }) questions.append(question) # Shuffle and select only num_questions #print(questions) random.shuffle(questions) questions = questions[:num_questions] print(json.dumps({ \"questions\": questions, \"topic_name\": topic_name, \"topic_id\": topic_id })) conn_moodle.close() except Exception as e: print(json.dumps({\"error\": f\"Error fetching questions: {str(e)}\"})) sys.exit() quiz.php //quiz.php \u003c?php require_once('../../config.php'); require_login(); if (session_status() == PHP_SESSION_NONE) { session_start(); } $userid = $USER-\u003eid; $topic_id = $_SESSION['topic_id'] ?? null; $topic_name = $_SESSION['topic_name'] ?? ''; if (!isset($_SESSION['quiz_questions']) || ($_SESSION['stored_topic_id'] ?? null) !== $topic_id) { $command = escapeshellcmd(\"python3 /var/www/html/moodle/local/learningpath/get_quiz_questions.py $topic_id\"); $output = shell_exec($command); if (!$output) { echo \"\u003cp style='text-align: center; color: red;'\u003e❌ Error fetching quiz questions.\u003c/p\u003e\"; exit; } $data = json_decode($output, true); if (!isset($data['questions']) || !is_array($data['questions'])) { echo \"\u003cp style='text-align: center; color: orange;'\u003e⚠️ No questions available.\u003c/p\u003e\"; exit; } $_SESSION['quiz_questions'] = $data['questions']; $_SESSION['stored_topic_id'] = $topic_id; } $questions = $_SESSION['quiz_questions']; // Quiz Header echo \"\u003cdiv style='width: 100%; text-align: center; margin: 20px 0;'\u003e \u003ch2 style='color: #003366; font-weight: bold; font-size: 28px;'\u003e📝 Quiz: $topic_name\u003c/h2\u003e \u003c/div\u003e\"; // Centered Quiz Box echo \"\u003cdiv style='max-width: 700px; margin: auto; padding: 20px; background-color: #fffddb; border-radius: 10px;'\u003e\"; echo \"\u003cform id='quizForm' method='post'\u003e\"; foreach ($questions as $index =\u003e $question) { $qid = htmlspecialchars($question['id']); $qtext = htmlspecialchars(strip_tags($question['text']), ENT_QUOTES); $qtype = $question['type']; $options = $question['options']; echo \"\u003cdiv style='margin-bottom: 25px;'\u003e \u003cstrong\u003eQ\" . ($index + 1) . \": $qtext\u003c/strong\u003e\u003cbr\u003e\"; if ($qtype === 'multichoice') { foreach ($options as $i =\u003e $option) { $choiceText = htmlspecialchars(strip_tags($option['text']), ENT_QUOTES); echo \"\u003clabel style='display: block; margin: 5px 0;'\u003e \u003cinput type='radio' name='q_$qid' value='$i' required\u003e $choiceText \u003c/label\u003e\"; } } elseif ($qtype === 'truefalse') { foreach ($options as $option) { $value = htmlspecialchars(strip_tags($option['text']), ENT_QUOTES); $label = htmlspecialchars($option['text'], ENT_QUOTES); echo \"\u003clabel style='display: block; margin: 5px 0;'\u003e \u003cinput type='radio' name='q_$qid' value='$value' required\u003e $label \u003c/label\u003e\"; } } echo \"\u003c/div\u003e\"; } echo \"\u003cinput type='hidden' name='topic_id' value='$topic_id'\u003e\"; echo \"\u003cinput type='hidden' name='user_id' value='$userid'\u003e\"; echo \"\u003cinput type='hidden' name='final_submit' value='1'\u003e\"; // Submit Only Button echo \"\u003cdiv style='text-align: center; margin-top: 30px;'\u003e \u003cbutton type='submit' formaction='quiz_submit.php' style='background-color: #28a745; color: white; padding: 12px 24px; font-size: 16px; border: none; border-radius: 5px; cursor: pointer;'\u003e✅ Submit Quiz\u003c/button\u003e \u003c/div\u003e\"; echo \"\u003c/form\u003e\"; echo \"\u003c/div\u003e\"; ?\u003e quiz_submit.php //quiz_submit.php \u003c?php require_once('../../config.php'); require_login(); if (session_status() == PHP_SESSION_NONE) { session_start(); } if ($_SERVER['REQUEST_METHOD'] === 'POST' \u0026\u0026 isset($_POST['user_id'], $_POST['topic_id'])) { $_SESSION['last_submitted_answers'] = $_POST; } if ($_SERVER['REQUEST_METHOD'] === 'POST' \u0026\u0026 !isset($_SESSION['quiz_submitted'])) { $userid = intval($_POST['user_id'] ?? 0); $topic_id = intval($_POST['topic_id'] ?? 0); $submitted = $_POST; $questions = $_SESSION['quiz_questions'] ?? []; if (!$questions || !$userid || !$topic_id) { echo \"\u003cp\u003eError: Missing required data.\u003c/p\u003e\"; exit; } $total = count($questions); $score = 0; foreach ($questions as $i =\u003e $question) { $qid = $question['id']; $qtype = $question['type']; $options = $question['options']; $submitted_key = 'q_' . $qid; $questions[$i]['student_answer'] = 'Not Answered'; $questions[$i]['is_correct'] = false; if (!isset($submitted[$submitted_key])) { continue; } $user_answer = $submitted[$submitted_key]; if ($qtype === 'multichoice') { $selected_index = intval($user_answer); if (isset($options[$selected_index])) { $questions[$i]['student_answer'] = $options[$selected_index]['text']; if (!empty($options[$selected_index]['is_correct'])) { $score++; $questions[$i]['is_correct'] = true; } } } elseif ($qtype === 'truefalse') { $user_answer_clean = strtolower(trim(strip_tags($user_answer))); foreach ($options as $opt) { $opt_clean = strtolower(trim(strip_tags($opt['text']))); if ($user_answer_clean === $opt_clean) { $questions[$i]['student_answer'] = $opt['text']; if (!empty($opt['is_correct'])) { $score++; $questions[$i]['is_correct'] = true; } break; } } } } $_SESSION['quiz_questions'] = $questions; $percentage = ($total \u003e 0) ? round(($score / $total) * 100, 2) : 0; $score_decimal = ($total \u003e 0) ? round($score / $total, 4) : 0.0; $escaped_userid = escapeshellarg($userid); $escaped_topic_id = escapeshellarg($topic_id); $escaped_score = escapeshellarg($score_decimal); $command1 = \"python3 /var/www/html/moodle/local/learningpath/scoring.py $escaped_userid $escaped_topic_id $escaped_score 2\u003e\u00261\"; $output = shell_exec($command1); $scriptPath = \"/var/www/html/moodle/local/learningpath/Quizupdate.py\"; $command = \"python3 $scriptPath $escaped_userid $escaped_topic_id $escaped_score 2\u003e\u00261\"; $output1 = shell_exec($command); $_SESSION['quiz_submitted'] = [ 'score' =\u003e $score, 'total' =\u003e $total, 'percentage' =\u003e $percentage, 'output' =\u003e $output1 ]; unset($_SESSION['last_submitted_answers']); unset($_SESSION['stored_topic_id']); header(\"Location: quiz_submit.php\"); exit; } if (isset($_SESSION['quiz_submitted'])) { $score = $_SESSION['quiz_submitted']['score']; $total = $_SESSION['quiz_submitted']['total']; $percentage = $_SESSION['quiz_submitted']['percentage']; $output = $_SESSION['quiz_submitted']['output']; echo \" \u003cdiv style='display: flex; justify-content: center; align-items: center; min-height: 100vh;'\u003e \u003cdiv style='max-width: 800px; width: 100%; text-align: left; background-color: #f3ffdb; padding: 40px 60px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);'\u003e \u003ch2 style='color: #2e7d32; font-size: 32px; text-align: center;'\u003e✅ Quiz Completed!\u003c/h2\u003e \u003cp style='font-size: 20px;'\u003e\u003cstrong\u003eScore:\u003c/strong\u003e $score / $total\u003c/p\u003e \u003cp style='font-size: 20px;'\u003e\u003cstrong\u003ePercentage:\u003c/strong\u003e $percentage%\u003c/p\u003e \u003ch3 style='margin-top: 30px; color: #2e2e2e;'\u003e📝 Review:\u003c/h3\u003e \u003cdiv style='margin-top: 15px;'\u003e\"; if (isset($_SESSION['quiz_questions'])) { foreach ($_SESSION['quiz_questions'] as $q) { $qtext = $q['text']; $correct = ''; foreach ($q['options'] as $opt) { if (!empty($opt['is_correct'])) { $correct = $opt['text']; break; } } $student_answer = $q['student_answer'] ?? 'Not Answered'; $is_correct = $q['is_correct'] ?? false; $feedback = $q['feedback'] ?? ''; $status_color = $is_correct ? 'green' : 'red'; $status_text = $is_correct ? 'Correct ✅' : 'Incorrect ❌'; echo \"\u003cdiv style='margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 6px; background-color: #fff;'\u003e \u003cp style='font-weight: bold;'\u003eQ: \" . html_entity_decode($qtext) . \"\u003c/p\u003e \u003cp\u003e\u003cstrong\u003eYour Answer:\u003c/strong\u003e \" . html_entity_decode(strip_tags($student_answer)) . \"\u003c/p\u003e \u003cp\u003e\u003cstrong\u003eCorrect Answer:\u003c/strong\u003e \u003cspan style='color: green;'\u003e\" . html_entity_decode(strip_tags($correct)) . \"\u003c/span\u003e\u003c/p\u003e \u003cp style='color: $status_color; font-weight: bold;'\u003e$status_text\u003c/p\u003e\"; if (!empty($feedback)) { echo \"\u003cp style='color: #444;'\u003e\u003cstrong\u003e💡 Feedback:\u003c/strong\u003e \" . html_entity_decode(strip_tags($feedback)) . \"\u003c/p\u003e\"; } echo \"\u003c/div\u003e\"; } } echo \"\u003c/div\u003e \u003cdiv style='text-align: center; margin-top: 30px;'\u003e \u003ca href='view.php'\u003e \u003cbutton style='padding: 14px 28px; font-size: 18px; background-color: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.3s;'\u003e ➡️ Proceed Next \u003c/button\u003e \u003c/a\u003e \u003ch3 style='font-size: 24px; color: rgb(45, 42, 107); margin-top: 20px;'\u003e\" . nl2br(htmlspecialchars($output)) . \"\u003c/h3\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e\"; unset($_SESSION['quiz_questions']); unset($_SESSION['quiz_submitted']); } ?\u003e Quizupdate.py #Quizupdate.py #!/usr/bin/env python3 import sys import variables from GA_functions import * if __name__ == \"__main__\": if len(sys.argv) \u003c 4: sys.exit(1) user_id = int(sys.argv[1]) current_topic= int(sys.argv[2]) score = float(sys.argv[3]) # Fetch student profile student_profile, path = fetch_student_profile(user_id) if student_profile is None: sys.exit(1) variables.student_profile= student_profile # Fetch supporting data clusters = fetch_clusters() learning_objects, _ = fetch_learning_objects() variables.learning_objects= learning_objects # Fetch attempts count from quiz_attempts table attempts = fetch_attempts(user_id, current_topic) # Update score and path new_path = update_score(student_profile, score, attempts, path, clusters, variables.max_distance, learning_objects) # Save updated student profile update_student_profile(user_id, student_profile, new_path) scoring.py #scoring.py import pymysql import json import sys import variables # Usage: python store_score.py \u003cuserid\u003e \u003ctopic_id\u003e \u003cscore\u003e userid = int(sys.argv[1]) topic_id = int(sys.argv[2]) score = float(sys.argv[3]) # score can be a float try: conn = pymysql.connect( host=variables.HOST, user=variables.USER, password=variables.PASS, database='fyp' ) cursor = conn.cursor() # Fetch existing scores and attempts for this user-topic cursor.execute(\"SELECT scores, attempts FROM quiz_attempts WHERE student_id=%s AND topic_id=%s\", (userid, topic_id)) row = cursor.fetchone() if row: current_scores, current_attempts = row if current_scores is None: scores_dict = {} else: try: scores_dict = json.loads(current_scores) except json.JSONDecodeError: scores_dict = {} scores_dict[str(current_attempts)] = score # Use current attempt number as key (string) # Update only the scores cursor.execute( \"UPDATE quiz_attempts SET scores=%s WHERE student_id=%s AND topic_id=%s\", (json.dumps(scores_dict), userid, topic_id) ) conn.commit() print(json.dumps({\"status\": \"updated\", \"attempt\": current_attempts, \"score\": score})) else: # First time inserting — default attempt is 1 scores_dict = {\"1\": score} cursor.execute( \"INSERT INTO quiz_attempts (student_id, topic_id, scores, attempts) VALUES (%s, %s, %s, %s)\", (userid, topic_id, json.dumps(scores_dict), 1) ) conn.commit() print(json.dumps({\"status\": \"inserted\", \"attempt\": 1, \"score\": score})) cursor.close() conn.close() except Exception as e: print(json.dumps({\"error\": str(e)})) sys.exit() "},"title":"Quiz pages"},"/docs/getting-started/":{"data":{"for-a-more-detailed-guide#For a More Detailed Guide":"Setting up the ServerThis guide will walk you through the steps to install and set up a Moodle server on a Linux-based system (Ubuntu). Moodle is a popular open-source learning management system (LMS) that is widely used for online learning environments.\nPrerequisites Before starting the moodle installation, ensure you have the following:\nA Linux server (Ubuntu is used in this guide). A user account with root privileges. Basic knowledge of the terminal and SSH (if you’re installing remotely). A working LAMP stack (Linux, Apache, MySQL, PHP). If you don’t have LAMP installed, follow the below steps first.\nMoodle Hardware Requirements The hardware requirements for Moodle can vary based on the number of users and the type of content. The following are general recommendations for a Moodle server:\nMinimum Hardware Requirements Disk Space:\n200MB for the Moodle code, plus as much as you need to store content. 5GB is probably a realistic minimum. Processor:\n1 GHz (min), 2 GHz dual-core or more is recommended. Memory:\n512MB (min), 1GB or more is recommended. For large production servers, 8GB plus may be required. Setting Up 1. Update your system: sudo apt update \u0026\u0026 sudo apt upgrade -y 2. Install Apache sudo apt install apache2 3. Install MySQL sudo apt install mysql-server 4. Install PHP and required extensions sudo apt install php php-mysqli php-xmlrpc php-soap php-intl php-mbstring php-xml php-zip php-curl php-gd 5.Install additional dependencies: sudo apt install libjpeg-dev libpng-dev libfreetype6-dev 6. Restart Apache to apply the changes: sudo systemctl restart apache2 For a More Detailed Guide For more detailed information on Moodle’s installation requirements, please refer to the official Moodle Installation Requirements.","moodle-hardware-requirements#Moodle Hardware Requirements":"","prerequisites#Prerequisites":"","setting-up#Setting Up":"","setting-up-the-server#Setting up the Server":""},"title":"Getting Started"},"/docs/moodle-installation-guide/":{"data":{"":"With all Moodle prerequisites in place, we can now proceed with the installation. The upcoming steps outline the complete installation process."},"title":"Moodle Installation Guide"},"/docs/moodle-installation-guide/create-an-empty-database/":{"data":{"":"Next, create a new, empty database for your installation. You need to find and make a note of the following information for use during the final installation stage:\ndbhost - the database server hostname. Probably localhost if the database and web server are the same machine, otherwise the name of the database server. dbname - the database name. Whatever you called it, e.g., moodle. dbuser - the username for the database. Whatever you assigned, e.g., moodleuser. Do not use the root/superuser account. Create a proper account with the minimum permissions needed. dbpass - the password for the above user. "},"title":"Create an Empty Database"},"/docs/moodle-installation-guide/detailed-guide/":{"data":{"detailed-guide-on-installing-moodle#Detailed Guide on Installing Moodle":"Detailed Guide on Installing MoodleFor a comprehensive and detailed guide on how to install Moodle, including system requirements, setup instructions, and troubleshooting, please refer to the official Moodle documentation given:\nInstalling Moodle - Moodle Documentation"},"title":"Detailed Guide"},"/docs/moodle-installation-guide/downloading-moodle/":{"data":{"":"","#":"Download and Copy Files into Place You have two options for downloading Moodle:\nPull the Code from the Git Repository\nFor this project, Moodle was downloaded via GitHub. This method is recommended for developers as it simplifies the upgrade process and version control. To pull the Moodle code, run the following command:\ngit clone -b MOODLE_405_STABLE git://git.moodle.org/moodle.git ℹ️ Tip: If you are downloading Moodle to your local computer and then uploading it to your hosted web site, it is usually better to upload the compressed Moodle file and then decompress on your hosted web site. If you decompress Moodle on your local computer, because Moodle is comprised of over 25,000 files, trying to upload over 25,000 files using an FTP client or your host’s “file manager” can sometimes miss a file and cause errors. Download the required version from official website You can download your required version from http://moodle.org/downloads and unzip the folder. Secure the Moodle Files It is vital that the files are not writeable by the web server user. For example, on Unix/Linux (as root):\nchown -R root /path/to/moodle chmod -R 0755 /path/to/moodle "},"title":"Downloading moodle"},"/docs/moodle-installation-guide/installing-moodle/":{"data":{"command-line-installer#Command Line Installer":"","example-of-using-the-command-line-as-root#Example of Using the Command Line (as root)":"Command Line InstallerIt’s recommended to run the command line as your system’s web user. You will need to know what the web user is for your system. For example:\nUbuntu/Debian: www-data CentOS: apache Example of Using the Command Line (as root) Substitute www-data with your system’s web user. Follow these steps:\n# Change the ownership of the Moodle directory to the web user chown www-data /path/to/moodle # Navigate to the Moodle CLI directory cd /path/to/moodle/admin/cli # Run the installation script using the web user sudo -u www-data /usr/bin/php install.php # Change the ownership back to root for security chown -R root /path/to/moodle "},"title":"Installing moodle"},"/docs/moodle-installation-guide/moodledata/":{"data":{"create-the-moodledata-directory#Create the \u003ccode\u003emoodledata\u003c/code\u003e Directory":"","example-unixlinux#Example (Unix/Linux)":"Create the moodledata DirectoryMoodle requires a directory to store all of its files, including uploaded files, temporary data, cache, session data, and more. The web server needs to have write access to this directory. When allocating space for this directory, especially on larger systems, consider how much free space you’ll need.\n⚠️ This directory must not be accessible directly via the web. Allowing web access would create a serious security risk. Do not place it inside your web root or inside the Moodle program files directory. Moodle will not install if this condition is not met. It can be placed anywhere convenient outside of the web root and Moodle program files directory. Example (Unix/Linux) To create the moodledata directory and set the correct permissions for the web server user, follow these steps:\n# Create the moodledata directory mkdir /path/to/moodledata # Set the permissions so anyone on the server can write to the directory chmod 0777 /path/to/moodledata "},"title":"MoodleData"},"/docs/user-profiling-website/":{"data":{"":"Add website details here.\nsection-wise specifications scoring specifications for each section range of scores taken mention it correctly changes r annoying change is good ig "},"title":"Use Profiling Website Specifications"}}